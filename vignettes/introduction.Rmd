---
title: "Introduction to tSpace"
author: "Denis Dermadi"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to tSpace}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

tSpace is an algorithm for trajectory inference. Depending on the platform used (FACS, CyTOF or single cell (sc) RNAseq) tSpace requires from the user to load previously transformed expression matrix into R workspace. As a general rules, FACS and CyTOF data have to be previously cleaned and pre-processed of all the noise/artifacts, and logicle, log `log` or ashin `asinh(x)` transformed. scRNAseq data should be normalized, log or square root `sqrt(x)` transformed and scaled. Expression matrix contians cells in the rows, and measured proteins/genes in the columns.

For the purpose of this tutorial we will use FACS data on T cell development in mouse thymus included in the package. To begin we load tSpace package.

## Loading the data and simple processing
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(tSpace)
data("tcell")
```

To make calculation faster, for the purposes of this tutorial, we will down-sample the dataset to 10000 cells, and take a look at the data.

```{r}
set.seed(111)

df <- tcell[sample(nrow(tcell), 10000),]

head(df)
```

Because tcell dataset has already been analyzed by tSpace, it contains columns *Cluster, tPCs, Index, Cell, Size, tsne1* and *tsne2*. For a new tSpace analysis we will use only phenotypic markers that start with column 12 until 23.

```{r}

head(df[12:23])

head(df)
```
## tSpace analysis 
To start with tSpace analysis we will load tSpace package and proceed with it's main function `tSpace`, for help on tSpace function and parameters type `?tSpace`.
For the first analysis we recommend to use default values, with the exception of waypoints (wp) which for smaller complexity data can be reduced to e.g. here 15. Usually 20 is a good number.
Dimensionaity reduction for visualizaton option (dr) is set here to **both** which will embed trajectory space matrix in PCA and UMAP. However later in this tutorial will be shown how to fine tune UMAP visualization or calcualte tSNE if user wants to use it. Seed number is recommended to type becasue of UMAP visualization consistency. If tSpace is used on multicore comuters, we recommend use of multiple cores because this will speed up calculation process significantly. 
### Commentary on tSpace parameters

#### Waypoints and number of trajectories 
In the accompanying [publication](https://doi.org/10.1101/336313), we examine (i) the effects of varying T (trajectory number) and effect of waypoints (ii) and the effects of graph number (G), K (L is maintained at 0.75K as default) and metric parameters. We demonstrate the power of waypoints (WP) and the importance of the number of trajectories on tSpace performance. WP are crucial element for tSpace to perform well. Based on our experience, the complexity of the dataset dictates number of WP; so far, we have used anything from 10 to 30 waypoints. 100-200 trajectories are needed to reveal the details of branching, however, for final analysis we suggest to calculate preferably larger number of trajectories (~1000) or ground truth if working with fewer than 10000 cells.

#### Comments on K and L 
Furthermore, we compare the effect of the number of sub-graphs, and varying K, L and different metrics (Euclidean and Pearson) and demonstrate the robustness of the output to K, the number of neighbors in the KNN graph, as long as K is kept reasonably low (but high enough for connectivity of the KNN graph). Intuitively large K, by increasing the number of ‘paths’ between cells, can lead to unwanted connections (short circuits) to developmentally more distant or altogether unrelated cells. We suggest to keep K small, and set the default to K=20. The parameter L defines the subset of K connections around each cell to be preserved in each of the sub-graphs, thus L must be < K. Keeping K and L small increases the sparseness of the graphs (reducing aberrant paths); but the ratio of L to K determines the independence of sub-graphs (which is also important to reduce the contribution of short-circuits). If L is kept as `NULL` tSpace will determine it as 0.75*K, a value that works well in all datasets we have analyzed. User can override that default by simply specifying L value.

#### Comments on number of graphs
Increased number of sub-graphs (graph parameter) can potentially contribute to noisy connections between cell types that are not developmentally related, however from developmental point of view, irrespective of choice of graph numbers cells are ordered correctly.

#### Comments on metrics
In our analysis we used Euclidean and Pearson correlation metric, all commonly used in single cell analysis. Selection of metrics is dependent on the data type. For example, Euclidean distances may over-emphasize the contribution of phenotypic markers that are very highly expressed, unless markers are scaled to a similar range prior to tSpace. Pearson metric intrinsically compensates for this, focusing on the profile shapes rather than magnitudes.


```{r}
# This calculation should be done in 20 minutes

ts <- tSpace(df = df[12:23], K = 20, L = NULL, D = 'pearson_correlation', graph = 5, trajectories = 200, wp = 15, dr = 'both', seed = 1111, core_no = 2)

```

Output of the tSpace function is a list of objects: 1. ts_file: a data frame of pca and/or umap embbedings of trajectory space matrix and input data, 2. pca_tspace and/or umap_tspace: pca and/or UMAP objects. pca object contians all the outputs of pca analysis, umap contians all the outputs of the umap analysis, see umap 3. tspace_matrix: trajectory space matrix with calculated distances. These objects can be extracted by using `$` operator.

```{r}

visualization <- ts$ts_file

head(visualization)

```

For visualization we can use either tPCs or umap coordinates, and becaue we have previously assigned cell annotations, we will use them for visualization. First we show ggplot method, and then a 3D option using `plotly` package.

```{r}

visualization$Cell <- as.factor(df$Cell)

library(ggplot2)

ggplot(visualization, aes(tPC1, tPC2, color = Cell))+
  geom_point()+
  scale_color_manual(values =  c('gray85', 'red', 'orange', 'blue', 'limegreen', 'skyblue', '#88fcd1', '#ee00a4', 'purple', 'black', 'pink', 'gold', 'firebrick', 'green'))+
  theme_classic()

ggplot(visualization, aes(tPC1, tPC3, color = Cell))+
  geom_point()+
  scale_color_manual(values =  c('gray85', 'red', 'orange', 'blue', 'limegreen', 'skyblue', '#88fcd1', '#ee00a4', 'purple', 'black', 'pink', 'gold', 'firebrick', 'green'))+
  theme_classic()


library(plotly)

p3d <- plot_ly(visualization, x = visualization$tPC1, y = visualization$tPC2, z = visualization$tPC3, color = visualization$Cell, colors = c('gray85', 'red', 'orange', 'blue', 'limegreen', 'skyblue', '#88fcd1', '#ee00a4', 'purple', 'black', 'pink', 'gold', 'firebrick', 'green'), marker = list(size = I(4)), type = 'scatter3d', text = ~paste("Pop: ", visualization$Cell, "<br>Index: ", visualization$Index) ) %>%  
      layout(paper_bgcolor='transparent')

p3d

```


## Isolation of the specific trajectory

Due to downsampling, DN2 population is not anymore abundant enough to be used as a start of the trajectory. So, let's say we want to isolate a trajectory starting from DN3 population all the way to CD4 recent emigrants. 

First, We have to find trajectories that start from DN3 population. We can do that by determining which trajectories from matrix `tspace_matrix` start from the cells around trajectory start (DN3 population) using cell indices. 
```{r}

dn3.trajectories <- ts$tspace_matrix[,which(colnames(ts$tspace_matrix) %in% paste0('T_', t.dn3.cd4[which(t.dn3.cd4$tPC3 < -0.04), 'Index']))]


ggplot(visualization, aes(tPC1, tPC3, color = dn3.trajectories[,1]))+
  geom_point()+
  scale_color_gradientn(colours = c('magenta', 'gold', 'black'))+
  theme_classic()

ggplot(visualization, aes(tPC1, tPC3, color = dn3.trajectories[,2]))+
  geom_point()+
  scale_color_gradientn(colours = c('magenta', 'gold', 'black'))+
  theme_classic()

ggplot(visualization, aes(tPC1, tPC3, color = dn3.trajectories[,3]))+
  geom_point()+
  scale_color_gradientn(colours = c('magenta', 'gold', 'black'))+
  theme_classic()

```

Now, after inspection of all three isolated trajectories we see that they are pretty much concordant and we can calcualte average trajectory of these three trajectories, which can be used for a heatmap that will show abundace changes of other protiens along the trajectory. 

```{r}

visualization$trajectory_dist <- rowMeans(dn3.trajectories)
```

Next, we have to isolate cells that are on the desired trajectory, without branch towards singlee CD8 T cells. We can do that by filtering out cells using their embeddings in tPC1 and tPC3, as shown in below figure. Here we used tPC1 and tPC3 because these two visually represent trajectories better than tPC1 and tPC2.

```{r}
ggplot(visualization, aes(tPC1, tPC3, color = Cell))+
  geom_point()+
  scale_color_manual(values =  c('gray85', 'red', 'orange', 'blue', 'limegreen', 'skyblue', '#88fcd1', '#ee00a4', 'purple', 'black', 'pink', 'gold', 'firebrick', 'green'))+
  geom_vline(xintercept = -0.001)+
  geom_hline(yintercept = 0.01)+
  theme_classic()

t.dn3.cd4 <- visualization[which(visualization$tPC1 < -0.001 & visualization$tPC3 < 0.01), ]

ggplot(visualization, aes(tPC1, tPC3, color = 'Rest'))+
  geom_point()+
  geom_point(data = t.dn3.cd4, mapping = aes(tPC1, tPC3, color = 'Isolated trajectory'))+
  theme_classic()

```

t.dn3.cd4 object contains only desired cells from DN3 to CD4 T cells. To order cells based on their trajectory distances and perform smoothing of the expression values along the isolated developmental sequence we will use a helper function `bin.trajectory`. For detailed description of the function and paramters check out`'?bin.trajectory`. 

```{r}

smooth.df <- bin.trajectory(x = t.dn3.cd4[,24:35], trajectory = t.dn3.cd4$trajectory_dist, n = 250, trim=T, stat = 'median')

clean.df <- smooth.df[!is.na(smooth.df[,1]),]

heatmap(as.matrix(t(clean.df[,1:12])), Rowv = NA, Colv = NA, scale = 'none', col = cm.colors(12))

```
Note 1: during smoothing some bins may not contain any cells and average values will be NA, because of that we remove these rows `!is.na(smooth.df[,1])`. 

Note 2: if option "smooth" is used output will not be bins but cubic smoothed values for single events. 

